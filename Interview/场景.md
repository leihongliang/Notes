
## 计算大小


```
1int = 4Byte(字节)
1double = 8Byte(字节)
1亿 = 10^8
1亿个int = 10^8 / 1024 / 1024 /1014 * 4= 0.093 * 4 = 0.372G
1G = 2.5亿个int
```

## 三个节点日志,每个节点两千万,有时间和IP等信息,如何设计系统查询一个时间

## left join

> 给你两张表，表A和表B，其中表A有3行数据，表B有5行数据，表A left join 表B后有几条

1. 如果表A中的每一行都与表B中的至少一行匹配，那么左连接的结果将有3行，B表没有匹配上的也会有3条, 补null
2. 如果表A中的某一行有多个匹配的行在表B中，那么左连接的结果将有多于3行的数据，最大是5行

总结起来，当进行左连接时，如果左表（表A）的每一行都与右表（表B）中的至少一行匹配，或者某些行有多个匹配行，那么左连接的结果将有多于3行的数据。具体的行数取决于匹配的情况。

## 存在

> 如何在大量的数据中判断一个数是否存在？

假如是java语言，int占4字节，32bit，每个数字是int类型存储，就是40亿个int需要的空间大小就是 16GB多

**思想**

**位图**，就是用一个或多个 bit 来标记某个元素对应的值，而键就是该元素。采用位作为单位来存储数据，可以大大节省存储空间。

位图法的思想类似于hash寻址，首先初始化一个int数组，每个元素对应32位比特，将40亿个元素分别读入内存，对int数组中的元素比特位进行标记，如果存在，标记为1即可。标记完之后，即可快速判定某个元素是否在10亿个正整数当中，时间复杂度为O(1)。

[Java数据结构之位图的简单实现和使用](https://www.jb51.net/article/283310.htm)

**缺点**

- 数据碰撞。比如将字符串映射到 BitMap 的时候会有碰撞的问题，那就可以考虑用 Bloom Filter 来解决，[Bloom Filter](https://my.oschina.net/freelili/blog/3001045) 使用多个 Hash 函数来减少冲突的概率。

- 数据稀疏。又比如要存入(10,8887983,93452134)这三个数据，我们需要建立一个 99999999 长度的 BitMap ，但是实际上只存了3个数据，这时候就有很大的空间浪费，碰到这种问题的话，可以通过引入 Roaring BitMap 来解决

## 有限类型数据取最大

> 海量ip数据，取频率最高(种类有限)，从海量日志中提取出某日访问次数最多的那个IP。

IP是32位的二进制数字，最多有个2^32（4亿）个IP。使用hash将ip直接存入内存，然后进行统计。

同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大的几个）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。

## 无限类型数据取最大

>
> 搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录（总数是1千万，但如去重，不超过3百万个。请你统计最热门的10个查询串，要求使用的内存不能超过1G。

hash/trie树+堆。
1. 先对这批海量数据预处理，在O（N）的时间内用Hash表完成排序;
2. 借助堆这个数据结构，找出Top K，时间复杂度为N‘logK。 即，借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，最终的时间复杂度是：O（N） + N’* O（logK），（N为1000万，N’为300万）。
2. 采用trie树（代替hash表），关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。

## topN词频

> 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。

1亿 = 0.625亿个词

取模分成n份(若其中有超过内存的还可以再分)+hash/trie树+堆

1. ==切分==。顺序读文件中，对于每个词x，取`hash(x)%5000`，然后按照该值存到5000个小文件（记为x0,x1,…x4999）中。这样每个文件大概是200k左右。
2. ==排序==。对每个小文件，统计每个文件中出现的词以及相应的频率（可以采用trie树/hash_map等），并取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100个词及相应的频率存入新的文件，这样又得到了5000个文件。
3. ==归并==。下一步就是把这5000个文件进行归并（类似与归并排序）的过程了。

## 多个大文件，词频排序

## 问题： 有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。

取模(可选)+hashmap/tire树+堆/归并/mapreduce排序

1. 顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。 找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件（记为）。对这10个文件进行归并排序（内排序与外排序相结合）。
2. 一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。
3. 与方案1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。

5、两个大文件找共同（是否允许误差？）
问题：
　　给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？
分治算法+hash_set 或者 允许一定错误的布隆过滤器
1.分治算法：
　　估计每个文件安的大小为5G×64=320G，大于内存限制，考虑采取分治的方法。遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件中。这样每个小文件的大约为300M。同理遍历文件b，这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,…,a999vsb999）中，不对应的小文件不可能有相同的url。 求出1000对小文件中相同的url，把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。
2.布隆过滤器：
　　如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。

## 找不重复数

> 在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。2.5亿int= 1G

1. ==位图 2-Bitmap==（优化16倍）：
　　 采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。

## 是否存在某个数

> 问题： 给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？
> 快排+二分 或 位图 或 按搜索的数从最高位开始每次筛选一部分

1. 快速排序+二分查找。
2. ==位图 Bitmap==，优化32倍
   1. 申请512M的内存，一个bit位代表一个int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在
3. 按位比较
   1. 每一个数用32位的二进制来表示假设这40亿个数开始放在一个文件中。
4. 然后将这40亿个数分成两类:最高位为0 和 最高位为1 ，并将这两类分别写入到两个文件中，其中一个文件中数的个数<=20亿，而另一个>=20亿（折半），与要查找的数的最高位比较并接着进入相应的文件再查找。再然后把这个文件为又分成两类: 次最高位为0 和 次最高位为1，并将这两类分别写入到两个文件中，其中一个文件中数的个数<=10亿，而另一个>=10亿，与要查找的数的次最高位比较并接着进入相应的文件再查找。 … 以此类推，就可以找到了,而且时间复杂度为O(logn)，方案2完。

## 找最大的n个数

>  100w个数中找出最大的100个数。

1.用一个含100个元素的==最小堆==完成。复杂度为O(100w* lg100)。
2.采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比100多的时候，采用传统排序算法排序，取前100个。复杂度为O(100w* 100)。
3.采用局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，与排好序的100个元素中最小的元素比，如果比这个最小的要大，那么把这个最小的元素删除，并把x利用插入排序的思想，插入到序列L中。依次循环，知道扫描了所有的元素。复杂度为O(100w*100)。


## 大数排序
