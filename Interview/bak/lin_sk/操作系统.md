# 操作系统

## 进程线程

### 什么是进程什么是线程，有什么区别？

进程是运行中的程序，线程是进程中的一条执行流程

- 区别
  1. 进程是资源分配的最小单位，而线程是调度的最小单位
  2. 一个进程中可以包含多个进程
  3. 进程之间是资源独立并且互相不影响，而一个进程内的线程资源是共享的（代码段，数据段，打开的文件资源），并且一个线程挂掉会影响整个进程
  4. 进程的上下文切换速度较慢，而线程较快
  5. 进程的创建/销毁/调度开销较大，而线程较小

### 进程的状态

1. 运行：正在被CPU执行
2. 就绪：可运行，但CPU被其他进程所占用
3. 阻塞：等待某一时间发生后暂停，即使CPU控制也保持暂停
4. 创建：正在被创建
5. 结束：正在销毁
6. 挂起状态：因避免占用内存，将进程存入硬盘，分为阻塞挂起和就绪挂起

### 进程的状态转换

就绪>运行：当线程就绪时，调度程序选中该线程并分配处理机，则就绪变为执行状态

运行>阻塞：因为某些事件而发生阻塞，CPU暂停线程，由运行变为阻塞状态

阻塞>就绪：当等待事件结束，线程先由阻塞变为就绪状态，等待CPU执行变为运行状态

运行>就绪：比如时间片用完了，CPU由运行变为就绪状态

### 什么是进程的上下文切换

CPU从一个进程切换到另一个进程就叫做进程的上下文切换

上下文包括：虚拟内存、栈、全局变量等用户空间的资源，还有内核堆栈、寄存器等内核空间的资源

### 线程的上下文切换

相比于进程，虚拟内存、全局变量等共享资源就无法保存，保存私有资源即可（本地方法栈、虚拟机栈、程序计数器）

### 调度原则

- CPU利用率
- 任务吞吐量
- 周转时间
- 等待时间
- 响应时间

### 进程的调度方式

1. 先到先执行
2. 时间越短先执行
3. 响应比优先
4. 时间片轮转
5. 优先级
6. 多级反馈

### 线程的通信方式有哪些

1. 管道

   1. 匿名管道：用于父子进程间的通信
   2. 命名管道：FIFO，用于没有血缘关系的进程也可以进程间通信

2. 消息队列
   1. 消息队列是保存在内核中的消息链表

   2. 实际是保存在内核中的消息链表，可以支持不同格式的数据传输。但是由于要进行内核态到用户态的拷贝因此具有延迟性

3. 共享内存
   1. 在内存中划分中一块公共的区域使不同的进程都可以进行访问，同时使用信号量来实现访问的互斥性，从而避免数据错乱

4. 信号
   1. 内核与进程的直接交互，进程可以对信号进行三种处理：执行默认信号、捕获信号、忽略信号

5. socket用于不同主机的进程互相通信

### 产生死锁的条件

同时满足：

1. 互斥条件：同一个资源无法被多个线程同时拥有
2. 持有并等待条件：一个线程在获得资源1后，再想获取资源2，那么会等待并且不会释放资源1
3. 不可剥夺条件：一个线程在获得资源后，除非自己释放，否则其他线程无法获得
4. 环路等待条件：线程a持有资源1想要资源2，线程b持有资源2想要资源1，互相等待

###  避免死锁的方法

资源有序分配法：线程a和线程b获取资源的顺序相同

### 有哪些锁

1. 互斥锁：资源在同一时间只能单个线程进行访问，获取锁失败后则被挂起，带锁资源释放后唤起
2. 自旋锁：同互斥锁，但在获取锁失败后会不断重试
3. 读写锁：区分读写场景，读资源时获取读锁，并且读锁可以有多个，在写时获取写锁，写锁只有一个

以上均属于悲观锁

乐观锁：假定发生冲突的概率较低，先对资源进行修改，操作完之后对比信息（版本号）来判断是否发生冲突

### PCB包含哪些内容

1. 进程的描述信息：进程的唯一标识号，用户标识号
2. 进程的控制和管理信息：进程的状态，进程的优先级
3. 资源分配清单：有关内存空间地址的信息，所打开的文件列表和所使用的IO设备信息
4. CPU信息：CPU中各个寄存器的值

### 线程的实现

- 用户态实现：在用户态实现线程，基于线程函数库进行线程的创建、调度等工作，操作系统不可见
  - 优点：线程管理由程序控制更加灵活；切换速度快
  - 缺点：一个线程发起系统调用阻塞会导致整个进程阻塞f；线程开始运行，除非主动释放CPU其他线程无法将其打断；时间分片更少
- 内核态实现：在内核态实现线程，由操作系统来管理线程
  - 优点：内核线程发起系统调用而阻塞不会影响其他线程；时间片更多
  - 缺点：切换速度慢
- 轻量级进程（LWP）：内核支持的用户线程，每个LWP与一个内核相对应，可以和一个或者多个用户线程对应。

### 互斥和同步的概念

- 互斥：多进程/线程并发下，同一时刻只能有一个进程/线程进行操作
- 同步：多进程/线程并发下，不同线程/进程需要等待其他线程/进程的操作完成后再进行自己的操作

### 线程崩溃了进程也会崩溃吗

java不会，因为JVM重写了信号处理函数，可以使线程保持执行，同时抛出异常交给用户进行处理

### 用户态和内核态的区别

区别在于访问权限不同，处于内核态的CPU可以访问所有数据，处于用户态的CPU访问受限，并且无法占用CPU

程序一般运行在用户态，当进行系统调用时会进行使用陷阱指令进入内核态