# JAVA

## 基础概念

### java语言有哪些特点

- 简单易学
- 面向对象：封装，继承，多态
- 平台无关：虚拟机
- 安全性：java提供一些列安全防护措施和访问修饰符，限制直接访问操作系统
- 可靠性：异常处理与内存管理
- 高效性：执行效率还行
- 解释和编译并存：java先将程序编译为字节码，然后交给JVM解释器来运行

### JVM、JDK、JRE

JDK是功能齐全的JDK，它包括JRE，以及java编译器javac，还有一些常用的工具：javadoc（文档注释工具），jdp（调试工具），jconcole（可视化监控工具），javap（反编译工具）

JRE是java运行环境，它包含两个部分：JVM和java基础类库

JVM是运行java字节码的虚拟机，针对不同的操作系统有不同的实现，目的是相同的字节码文件能产生相同的结果。JVM不止一种，只要满足规范，任何人都可以开发自己的JVM

### 字节码是什么？为什么采用字节码

在java中，被JVM理解的代码就是字节码（.class文件）。它不面向任何特定的处理器，只面向虚拟机，因此java编译成字节码文件后，在任何操作系统上都可以运行。因此java具有跨平台移植性以及不错的执行效率。

### JIT和AOT

在JVM中，需要解释器逐行将字节码翻译成机器码执行程序，这样的效率不高。

因此引入了JIT，它属于即时编译，他采用惰性评估，在运行时找到热点代码，并编译成机器码后进行保存，从而提升了java运行效率。

AOT是直接将所有字节码编译成机器码，这种方式效率很高，但是与java语言的动态特性不太兼容，动态特性例如：在运行时生成并加载修改后的字节码

### JAVA和C++的区别

- java不提供指针来直接访问内存
- java单继承，c++多继承
- java有自动内存管理垃圾回收机制，无法手动释放内存
- java只能重载方法，c++还可以重载操作符

......

## 基础语法

### 注释有哪几种形式

- 单行注释
- 多行注释
- 文档注释：用于生成java开发文档

### 基本类型和包装类型的区别

- 用途：基本数据类型一般用于常量和局部变量，而包装类一般用于方法参数，并且可以使用泛型
- 存储位置：基本数据类型存于栈中，包装类（非static）存储在堆中
- 大小：基本数据类型占用空间很小，而对象会相对较大
- 比较方式：基本数据类型可以直接用==比较，而包装类之间比较用equals
- 默认值：包装类的默认值为null

### 包装类型的缓存机制

Byte、Short、Integer、Long缓存了[-128, 127]的值，Character缓存了[0, 127]的值，Boolean缓存了true和false

因此当自动装箱（valueOf方法）时，如果是缓存中的值则直接访问缓存对象，因此出现以下现象

```java
Integer i1 = 33;
Integer i2 = 33;
System.out.println(i1 == i2);// 输出 true

Integer i1 = 255;
Integer i2 = 255;
System.out.println(i1 == i2);// 输出 fasle

Integer i1 = 40;
Integer i2 = new Integer(40);   // 创建了新对象
System.out.println(i1==i2);  // 输出false
```

### 静态方法为什么不能调用非静态成员

因为静态方法在类加载时就一起加载了，而非静态成员是在类实例化的时候才加载。相当于静态方法加载的时候，非静态成员还不存在，因此无法调用

### 重载和重写的区别

重载：指在同一个类中，方法名相同，但是参数列表（个数，类型，顺序）、返回值、修饰符、异常可以不同；重载用于让同一个方法对不同的参数列表做出不同的响应

重写：发生在子类中，子类继承父类的方法可以将其重写，重写的方法名必须相同，参数列表必须相同，返回值、修饰符以及异常要小于父类；重写用于让子类改造父类方法的内部逻辑

### 接口和抽象类的区别

- 一个类可以实现多个接口，但只能继承一个抽象类
- 接口中没有构造方法和普通成员变量，抽象类中可以有构造方法和成员变量
- 接口和抽象类都可以有静态成员变量，但接口默认且只能public final修饰，抽象类不限制
- 抽象类可以有普通方法；接口只能有抽象方法，在JDK8可以有默认方法，在JDK9后可以有私有方法
- 抽象类可以有静态方法；接口没有，在JDK8可以有，且只能被接口类所调用

## 面向对象

### 面向对象和面向过程的区别

两者的区别在于解决问题的方式不同：

面向过程：将解决问题的过程拆分成一个个方法进行解决

面向对象：会抽象出一个对象，通过对象的方法来解决问题；同时具有易维护、易复用、易拓展的优点

### 构造方法有哪些特点

- 方法名与类名一致
- 没有返回值，不能用void修饰
- 创建对象时自动调用
- 不可重写，可以重载

### 面向对象三大特征

- 封装：只对象可以隐藏自己的属性和方法不被外界访问
- 继承：可以基于现有类的基础上定义新的子类
- 多态：指一个对象可以拥有多种形态，具体的表现为父类的引用指向子类的实例

### 引用拷贝、浅拷贝和深拷贝

引用拷贝：直接复制对象的引用地址

浅拷贝：开辟一个新的对象，原对象中的引用类型的属性采用引用拷贝；结果是对象的引用地址不同，但内部属性的引用地址相同（Object提供的clone（）方法就是浅拷贝）

深拷贝：开辟一个新的对象，原对象中的引用类型的属性也会开辟新地址就行值复制，结果是对象的引用地址不同，且内部属性的引用地址也不同

### this()和super()在构造方法中的区别

this()表示调用同类中的另一个构造器；super()表示调用父类的一个构造器

this()和super()都需要在构造器的第一行调用，且只能调用一个

## Object

### ==和equals的区别

==：对于基本数据类型，比较的是值；对于引用类型，比较的是内存地址

equals：如果没有重写，与“==”等价；如果重写了，就按重写的逻辑来

### 为什么要有hashcode()方法

Object提供hashcode（）方法，返回对象的散列码，用于快速确定对象在散列表中的位置，因此hashcode方法只在散列表中有用。但是hashcode相等不代表真的相等，可能有hash碰撞的情况。因此java中还会用equals方法来判断对象是否真的相等。因此如果要在散列表中正确的去重对象，不仅要重写hashcode方法还要重写equals方法。

### final、finalize 和 finally 的不同之处?

- final：用于修饰变量，被final修饰的变量不可更改
- finalize：Object自带的方法，在对象被垃圾回收前调用
- finally：用于异常捕获处理，与try-catch配合使用，表示最终都会执行的代码

## String

### String、StringBuilder、StringBuffer

String：不可变，线程安全，适用于不常修改的场景

StringBuilder：可变，线程不安全，适用于单线程大量修改的场景

StringBuffer：可变，线程安全，适用于多线程大量修改的场景

### String为什么是不可变的

String内部维护一个char[]数组，其被private和final修饰

private：将内部数据私有化，同步不提供更改的操作

final：使内部数据无法继承从而避免子类继承来修改

### 字符串+

“+”和“+=”在字符串操作时，java是对这两个操作符重载了，在底层，会创建StringBuilder对象，使用append方法拼接，然后返回toStirng方法产生的对象

但是在循环场景下会大量地创建StringBuilder对象，导致性能也不高，最好还是自己使用StringBuilder（java9后没有这个问题）

###  String s1 = new String("abc");这句话创建了几个字符串对象？

1或2：

- 常量池中没有“abc”：会先在堆中创建一个String对象，然后检查常量池中是已有String，没有就再在堆中创建一个String对象，然后该对象的引用保存到常量池，最后为一开始的String对象初始化。

- 常量池中没有“abc”，则就在堆中创建一个String对象。

### String.intern()

将字符串保存到常量池：如果有了就返回引用；没有就创建并返回

### 常量折叠

常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。

只有编译器在程序编译期就可以确定值的常量才可以：

- 基本数据类型( `byte`、`boolean`、`short`、`char`、`int`、`float`、`long`、`double`)以及字符串常量。

- `final` 修饰的基本数据类型和字符串变量

- 字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（<<、>>、>>> ）

## 异常

### Exception和Error有什么区别

两者都继承Throwable类

- Exceptiton：程序本身可以处理的异常，可以被try-catch捕获
- Error：程序本身无法处理的异常，例如虚拟机错误（`Virtual MachineError`）、内存溢出(`OutOfMemoryError`)、类定义错误（`NoClassDefFoundError`）等等

### CheckedException和UnCheckedException有什么区别

CheckedException和UnCheckedException都继承自Exception类

- CheckedException：受检查的异常，在编译时会对其检查，如果没有做异常处理则无法通过编译。常见的受检查异常有：IO 相关的异常、`ClassNotFoundException`、`SQLException`...

- UnCheckedException：不受检查的异常，即使不做处理也能通过编译，一般就是RuntimeException，常见的有：

  - `NullPointerException`(空指针错误)

  - `IllegalArgumentException`(参数错误比如方法入参类型错误)
  - `NumberFormatException`（字符串转换为数字格式错误，`IllegalArgumentException`的子类）

  - `ArrayIndexOutOfBoundsException`（数组越界错误）

  * `ClassCastException`（类型转换错误）

  - `ArithmeticException`（算术错误）

  - `SecurityException` （安全错误比如权限不够）

  - `UnsupportedOperationException`(不支持的操作错误比如重复创建同一用户)

### Throwable常用方法

- `String getMessage`：获取异常发生的简要信息
- `String toString`：获取异常的详细信息
- `String getLocalizedMessage`：获取本地化信息，如果没重写，跟`get Message`是一样的
- `void printStackTrace`： 打印异常信息

### finally中可以写return吗

不行，会导致try或catch中的return语句失效

### finally一定会执行吗

以下情况不会执行：

- 虚拟机中断
- 线程死亡
- CPU关闭

### throw和throws的区别

- throw：手动抛出异常
- throws：在方法头中显示声明抛出异常，交给调用方法者处理

### 如何使用 `try-with-resources` 代替`try-catch-finally`？

- 使用范围：实现了`java.lang.AutoCloseable`或者 `java.io.Closeable` 的对象，Java中大部分资源类都继承了这个接口
- 执行顺序：先关闭资源，再运行catch或者finally

### 异常使用有哪些需要注意的地方

- 不要把异常定义为静态变量，会导致异常栈信息错乱
- 抛出的异常要有意义
- 尽量使用更为具体的异常
- 打印日志后就不要抛异常了

## 泛型

### 什么是泛型

定义：泛型是jdk5引入的新特性，可以将数据类型作为参数传递

作用：增强代码的可读性和可靠性

使用：泛型类，泛型接口，泛型方法

注意：静态方法无法使用类所接受的泛型

### 项目中哪里用到了泛型

- 定义自定义返回结果接口
- 定义通用方法工具类

### 如何定义一个泛型方法

传入参数`Class<T>`~类对象，返回值前加上`<T>`表明泛型方法，在方法内部使用`newInstance`方法获取实例对象

### 泛型的上限和下限

在使用泛型时可以指定泛型的上限和下限

- 上限：`T extends Number`表示数字类型的子类
- 下限：`Info<? super String> temp`表示只能接受字符串和Object

### 为什么说java泛型是伪泛型

在jdk1.5引入了泛型擦除，就是在编译阶段java会将所有泛型转为具体的类型，在运行时就跟没有泛型一样

## 反射

### 什么是反射

反射使得我们能够在程序运行过程分析类并执行类的方法，通过反射，可以获取到任意类的所有属性和方法并且可以修改属性或执行方法

### 反射的优缺点

- 反射使代码更加灵活，许多框架的实现都大量使用了反射
- 反射会增加安全性问题，并且反射的性能不高

### 反射的应用场景

- 动态代理（Spring）
- 注解

## 注解

### 什么使注解，有什么作用

注解是一种特殊的注释，用于修饰方法、类、变量，提供信息在运行时使用，具体作用：

- 生成文档
- 编译检查
- 编译时处理，例如动态生成代码
- 运行时处理，例如反射创建对象

### 注解的运行方法

注解在解析后才会生效，分为两种：

- 编译时解析：在编译时进行检查，例如@Override
- 运行时解析：例如Spring提供的注解，@component，在运行时通过反射处理

## SPI

### 什么是SPI

字面意思为服务提供者的接口，它将服务调用方和服务实现分离开来，提升程序的拓展性、可维护性，例如jdbc驱动接口由不同的数据库厂商分别实现

### SPI和API的区别

API是由服务提供者制定接口规则并实现

SPI是由接口调用者制定接口规则，由服务提供者实现

### SPI的优缺点

优点：使程序更加灵活

缺点：

- 需要加载所有的实现类

- 并发问题？

## 序列化和反序列化

### 什么是序列化，什么是反序列化

- 序列化：将数据结构或对象转换成二进制字节流的过程
- 反序列化：将序列化生成的二进制字节流转换成数据结构或对象的过程

常见应用场景：

- 网络传输
- 存储到数据库
- 存储到文件（IO）
- 存储到内存

### 哪些字段不会被序列化

- transient修饰的变量：序列化时会赋默认值
- static修饰的变量

### 常见的序列化协议

- 基于二进制流：Hession，Kryo，ProtoBuf，ProtoStuff
- 基于文本：json，xml

### 为什么不推荐使用JDK自带的序列化技术

- 不支持跨语言
- 性能差，生成的序列化文件大
- 存在安全问题

## I/O

### 如何从数据传输方式理解IO流

从数据传输角度，IO流可以分为：

- 字节流：读取单个字节，常用于处理二进制数据，例如图片、视频等等
- 字符流：读取单个字符，常用于处理文本数据，例如文本文件（本质也是二进制，但采用某种编码使得人可以阅读）

### IO流的四个抽象类基类

- InputStream：输入字节流
- OutputStream：输出字节流
- reader：输入字符流
- writer：输出字符流

### IO流为什么要分字节流和字符流

- 虚拟机将字节转换为字符的过程比较耗时
- 如果不知道编码类型，字节流很容易出现乱码问题

### IO中有哪些设计模式

- 装饰器模式：可以在不改变原有对象的情况下拓展功能；适用于继承关系非常复杂的场景（相当于不用继承就获得核心功能）；例如：`BufferedInputStream`（字节缓冲输入流）创建时可以传入 `FileInputStream` ，从而增加缓冲功能
- 适配器模式：让接口不兼容的类协调工作，例如将字节流适配成一个字符流
- 工厂模式：用于统一创建对象，比如 `Files` 类的 `newInputStream` 方法用于创建 `InputStream` 对象
- 观察者模式：NIO中的文件目录监听用到了观察者模式，...

### 什么是同步和阻塞？

- 阻塞和非阻塞：程序级别的，描述程序在访问IO资源时，如果IO资源还没有准备好，前者等待，后者继续执行，并且使用线程不断询问直到准备好
- 同步和非同步：操作系统级别的，描述操作系统在收到程序访问IO请求时，如果IO资源还没准备好，前者不响应直到资源准备后，后者会返回一个标记（后续进行通知的地方），等资源准备好后再用事件机制返回给程序

### 什么是多路复用IO

系统调用由多个任务组成，将这些任务拆分执行

### 什么是信号驱动IO

应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。

### BIO、NIO 和 AIO 的区别？

BIO：同步阻塞，线程会一直等待阻塞直到IO操作结束

NIO：同步非阻塞，线程会先询问是否准备就绪，如果没有准备好先去做别的事，过会儿再来问

AIO：异步非阻塞，线程发起IO请求后就返回，让别的线程去做IO操作，操作完了再通知

### 什么是零拷贝，有什么用

传统IO读写数据需要内核空间和用户空间来回复制，在高并发场景下，性能开销比较大

### 零拷贝的实现

mmap + write：

- 应用程序调用`mmap()`后，DMA会将磁盘的数据拷贝到内核缓冲区，接着做映射，使应用程序和内核共享缓冲区
- 应用程序调用`write()`后，CPU会直接将内核缓冲区的数据拷贝到socket缓冲区，从而在内核中实现了直接拷贝
- 最后由socket将数据DMA拷贝到网卡中

这样操作减少了内核态到用户态的拷贝次数（3次），但仍然由CPU搬运数据，过程包含两次系统调用，四次上下文切换

sendfile

- 网卡不支持 SG-DMA：过程与mmap + write类似，同样由CPU进行拷贝，不过只进行了一次系统调用，两次上下文切换
- 网卡支持SG-DMA：DMA会将磁盘的数据拷贝到内核缓冲区，网卡使用SG-DMA方式直接从内核缓冲区拷贝数据；这种方式只有两次拷贝，没有在内存空间中拷贝数据，实现了真正的零拷贝