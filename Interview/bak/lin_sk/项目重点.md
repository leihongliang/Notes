## 黑马点评

### 基于Spring拦截器+ThreadLocal实现请求校验，token刷新以及用户信息存储

设置两个拦截器：

- 刷新token拦截器：拦截所有请求，检查请求中是否带有token，有的话就会查询Redis获得用户对象，放入到ThreadLocal供后续服务使用并且同时会刷新token的有效期
- 登录校验拦截器：拦截需要登录的页面请求，直接查询ThreadLocal中是否有用户对象，没有则进行拦截，有就放行

token什么产生：

1. 用户通过手机号验证码登录，后端首先检查验证码是否正确，再检查用户是否存在，不存在就进行注册
2. 得到用户对象后，通过UUID生成一个随机token，将token和用户对象保存到redis中，然后将token返回给前端

### 基于MySQL+Redis 实现商户信息缓存并采用主动更新策略保证数据一致性

保持数据一致性的方案：

- 超时剔除：查询数据库时如果命中则返回，如果没有命中则查询数据库并更新缓存，同时设置超时时间
- 主动更新：当修改数据时，先更新数据库，再删除缓存，采用事务保证原子性

解决缓存击穿的解决方案：

- 缓存空值

解决缓存雪崩的解决方案：

- 超时时间加随机值

### 基于互斥锁+逻辑过期技术方案解决热点key 导致的缓存击穿问题

- 逻辑过期：给数据设置逻辑过期，当查询请求时，通过逻辑过期时间来主动判断数据是否已经过期
- 互斥锁：数据已过期就尝试获取互斥锁，如果获取锁成功，则开启一个新的线程去对缓存进行重构，在重构期间的查询都先放回旧值

### 基于lua脚本结合阻塞队列使用异步下单方式实现优惠券秒杀功能

- lua脚本：保证原子性。首先查询库存是否大于0，防止超卖问题；再查询用户是否已存在set中，保证一人一单；最后将订单添加到消息队列
- 阻塞队列：使用stream数据结构，开启一个线程不断尝试获取消息队列中的信息，获取到消息后解析订单并完成最终下单

### 基于Redis各类数据结构实现点赞排行、共同关注，订阅推送，签到统计等功能

- 点赞：点赞操作后首先判断是否已经点过赞，没有点过则进行点赞，先保存数据库，然后添加到ZSet集合，使用时间戳作为分数；已经点过则取消点赞，先删除数据库，再删除Zset集合中的user id；前端可以根据sorce排序显示前五名点赞的用户

- 共同关注：关注时先添加数据库记录，再添加到redis的set集合中；取关时先删除数据库记录，再删除到redis记录；查询共同关注时，就使用redis集合求取交集（intersect）
- 订阅推送：使用rediis的zset集合作为每个用户的即时信箱，发布笔记时，首先查询博主的所有粉丝，然后向所有粉丝信箱添加博客id并设置时间戳为分数；当用户上线查询推送消息时，就会从zset信箱查询并滚动分页显示
- 签到：使用bitMap按月统计用户的签到情况，用户登录时，会计算当前是本月的第几天，然后将该位设置位1表示签到
- UV统计：使用redis的Hyperloglog算法，用于统计百万级的浏览次数，内存占用低，测量结果是有大约0.81％

## 学成在线

### 基于MySql +MyBatis-Plus实现课程内容管理，包括树形表查询、分页查询等功能

课程类别信息具有多级分类，一级分类下有二级分类，呈树状结构。在MySQL中存储时，每一个节点作为一条记录，其中一个字段用来指示父节点。我们使用MySQL中的with recursive语句来进行递归查询。当我们查询某个类别时，使用递归语法，将要查询的类别节点作为根节点，查询出他的子节点，再以子节点作为根节点不断查询，从而查询出一个类别下的所有子类信息的记录。最后在后端对查询结果做一个封装然后返回给前端进行显示。

### 基于MinIO 分布式文件系统+IO 流+Md5 校验实现文件的断点续传与统一管理

**为什么用MinIO**：项目中提供图片上传，课程视频上传等功能。当前端将这些文件上传后，我们需要对这些文件进行存储和管理，而MinIO是一个轻量级的分布式文件管理系统，它容易部署和上手，并且具有不错的性能和可用性。因此我们项目采用MinIO来作为文件的统一管理中心，所有上传的文件都会保存在MinIO中并进行统一管理。

**分块上传流程**：

1. 检查分块：前端（js代码）首先计算文件的md5值作为文件的唯一标识，然后将文件做一个分块并标记序号。完成分块后，前端首先会请求后端依次查询各个分块文件是否已经上传过了，后端会去MinIO中做一个检查。
2. 上传分块：如果分块已经被上传，那么前端就跳过这个分块的上传，如果没有上传的话就会上传该分块。后端接收到文件后，会对文件进行解析，根据MinIO的规则设置文件名和路径，然后调用MinIO的API进行文件的上传
3. 合并分块：当前端确认所有分块都已经上传成功后，就会想后端发送一个合并分块的请求。后端收到请求后，就会调用MinIO的API进行文件的分块。
4. 完整性校验：合并完文件后计算md5值与前端传给我们的进行比较是否一致来确定文件是否完整，如果不完整则删除文件并抛出异常

### 基于XXL-JOB 分布式任务调度中心实现视频转码、数据同步等后台任务的定时执行

**为什么用XXL-JOB**：项目中涉及到视频文件，前端接受的视频文件编码格式是不统一的，为了支持在线播放，因此需要在后台对视频文件进行一个统一的转码处理。为了实现这个功能，我想到可以通过设置定时任务来调用线程处理视频。因此我们使用XXL-JOB来作为任务调度中心来实现定时任务技术方案。XXL-JOB是一个轻量级的任务调度中心，它易部署好上手，支持动态修改任务，任务分片等等。

**执行流程**：首先在后端创建执行器，然后在XXL-JOB任务调度中心进行注册，并设置定时任务。设置完成后，任务调度中心定时进行分片广播，收到广播后各个执行器扫描任务消息表，根据分片序号以及任务状态找到自己需要执行的任务，然后使用线程池利用多线程来执行属于自己的所有任务。在单个任务中，会将视频文件从MinIO中下载，然后调用工具类进行转码，完成后再将视频文件上传至MinIO，并且更新任务表中的状态信息。

**怎么高效执行**：使用XXL-JOB中分片广播的策略来调度任务。在这个策略下，当有大批量的任务时，会将任务平均的分配给所有的执行器。各个执行器基于线程池运行的，那么就可以充分利用服务器多核CPU的资源，并且XXL-JOB是支持分布式任务调度的，那么如果有多台主机也能充分利用硬件资源，从而实现高效执行。

### 基于Elasticsearch 实现课程关键字搜索、类别查找、分页查询以及高亮显示

**创建索引**：在中Elasticsearch创建索引，并指定Mapping（索引结构）。id等字段设置keyword类型用于完整匹配；用于查询的字段例如名字、描述信息设置分词器用于搜索；而一些敏感字段例如用户名则禁止索引。

**分词器设置**：分词器选用IK分词器，这款分词器对于中文分词具有不错的效果。设置analyzer（用于插入索引时分词）为ik_max_word分词器（最细粒度的拆分），设置search analyzer（用于查询时对查询文本分词）为ik_smart分词器（最粗粒度的拆分）。这样设置可以让建立索引时最大化的拆分内容，而在搜索时更加精确的匹配内容。

**搜索执行流程**：

1. 前端将匹配信息传给后端，包括分页信息和关键字、大分类、小分类、难度等级
2. 创建BoolQueryBuilder对象设置布尔查询语法：使用关键字对课程名称和课程描述两个字段设置must匹配语法，设置70%匹配度（代表70%以上的子句匹配才算匹配），并且提升课程名称的权值；使用大分类、小分类、难度等级设置过滤语法
3. 创建HighlightBuilder对象设置高亮语法：高亮字段为课程名称，设置样式字体标签用于前后拼接
4. 创建AggregationBuilder对象设置聚合搜索语法：对搜索结果按照大分类、小分类分组（不知道聚了干嘛用）
5. 将所有搜索查询语法对象封装到SearchSourceBuilder对象并设置分页参数，再将SearchSourceBuilder封装到SearchRequest，调用client发送请求
6. 对结果集进行处理，收集搜索结果封装后返回前端

### 基于SpringSecurity 采用Oauth2 协议实现用户密码登录、微信扫码登录的统一认证授权

**什么是SpringSecurity**：是一个功能强大且高度可定制的身份验证和访问控制框架，为 Java 应用程序提供身份验证和授权功能。它基于过滤器实现，可以对请求进行拦截。并且支持OAuth2认证

**什么是Oauth2协议**：一个授权协议，通过颁发令牌的方式，来获得对资源的访问权限。

**微信扫码登录流程**：

1. 浏览器生成二维码，用户扫码后进行授权，获取到微信授权码
2. 后端使用授权码向微信申请访问用户信息的令牌
3. 后端拿到微信的令牌后向微信获取用户信息
4. 后端拿到用户信息对用户设置相应的信息并进行保存
5. 后端生成一个jwt令牌返回给前端
6. 前端获得jwt令牌后，后续就可以使用jwt令牌访问项目资源

**统一登录认证流程**：

1. 通过传入的Username（Json数据）转AuthParamsDto对象
2. 获取AuthParamsDto对象中的authType
3. 通过ioc容器根据对象名和类型获取对应的认证方式实现类
4. 调用认证方式实现类执行方法进行认证
5. 认证失败返回null，Spring Security框架视为认证失败
6. 认证成功则调用getUserPrincipal方法授予权限
7. 最终封装为UserDetails对象交给Spring Security框架保存

### 基于第三方支付接口+RabbitMQ 实现扫码下单支付以及支付结果的异步通知

**支付流程**：

1. 用户点击支付按钮后，后端生成订单参数以及二维码返回给前端
2. 扫描二维码后就会跳转到支付宝收银台
3. 用户在支付宝收银台支付后，回跳到指定的return_url
4. 同时会将支付结果异步发送给指定的notify_ur

**异步通知流程**：项目中使用RabbitMQ作为消息队列，当支付服务完成支付后，将支付结果消息放入消息队列中，然后课程管理服务作为消费者，从消息队列中获取消息并进行相应的处理。

**如何保证消息可靠**：

1. 生产者确认机制

   - 发送消息前使用数据库事务将消息保证到数据库表中

   - 成功发送到交换机将消息从数据库中删除
2. mq持久化

   - mq收到消息进行持久化，当mq重启即使消息没有消费完也不会丢失。

   - 需要配置交换机持久化、队列持久化、发送消息时设置持久化。
3. 消费者确认机制
   - 消费者消费成功自动发送ack，否则重试消费。

## 微服务相关

### 微服务项目结构

- parent模块对依赖版本统一控制
- base模块提供公用的工具类、架构基础类库（包括异常处理器，日期格式配置）
- api模块为接口工程，对外提供访问接口
- service模块为业务工程，处理业务
- model模块为数据模型工程，提供存储数据模型类（PO）,数据传输模型类（DTO）

### Nacos什么作用

- 服务注册中心：也叫服务发现中心，微服务将自己注册到服务注册中心，服务间远程调用通过服务注册中心获取目标服务的地址，从而进行远程调用。市面上的服务注册中心有：Zookeeper、Eureka、Nacos、Consul，本项目使用Nacos。
- 配置中心：统一管理微服务的配置文件。

### Nacos配置中心如何生效

1. 首先配置nacos-config依赖
2. 添加配置文件，注意四部分：namespace、group、dataid及文件扩展名。
   - namespace：命名空间，项目的运行环境
   - group: 项目名
   - Dataid: 包括三部分：服务名、环境名、扩展名
3. 在项目工程配置boostrap.yml

### Nacos服务注册中心如何生效

1. 首先配置nacos-discovery依赖
2. 启动微服务，自动上传到nacos

### GateWay有什么作用

负载均衡、路由转发、统一认证

### GateWay转发流程

1. 微服务启动，将自己注册到Nacos，Nacos记录了各微服务实例的地址。

2. 网关从Nacos读取服务列表，包括服务名称、服务地址等。

3. 请求到达网关，网关将请求路由到具体的微服务。

### Feign如何生效

在启动类上增加@EnableFeignClients注解，并指定feignclient所在包

### 什么是熔断降级，怎么设置

- 熔断：当下游服务异常而断开与上游服务的交互，它就相当于保险丝，下游服务异常触发了熔断，从而保证上游服务不受影响。
- 降级：当下游服务异常触发熔断后，上游服务就不再去调用异常的微服务而是执行了降级处理逻辑，这个降级处理逻辑可以是本地一个单独的方法。

设置：

1. 在定义FeignClient接口时指定fallbackFactory 

2. 定义fallbackFactory，并重写调用的api方法，在内部定义降级处理逻辑
