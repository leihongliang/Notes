# JVM

## 运行时数据区域

### 程序计数器

线程私有，可以看作当前线程执行字节码的行号指示器，通过程序计数器读取下一条要执行的指令，从而实现程序的流程控制，并且在CPU切换线程时保存程序的执行位置。它的生命周期随着线程的创建而创建，随着线程的死亡和结束

### 虚拟机栈

线程私有，在方法调用后，会将一个栈帧压入虚拟机栈中，方法结束后弹出栈帧，栈帧中包含以下内容：

- 局部变量表：存放编译期可知的各种数据类型
- 操作数栈：用于存放方法执行过程产生的中间计算结果以及临时变量
- 动态链接：用于将符号引用转换为方法的直接引用
- 方法返回地址：方法退出或异常退出的地址

栈中可以发生的异常：

- 栈溢出：若不支持栈的动态扩展，当栈的深度达到最大值就发生栈溢出
- 内存溢出：若支持栈的动态拓展，当栈无法申请到足够的内存空间发生内存溢出

### 本地方法栈

线程私有，与虚拟机栈功能相同，在调用本地方法（native）时使用

### 堆

线程共享，存放对象实例，是内存管理主要区域，根据内存回收算法又可以分为：新生代、老生代、永生代

### 方法区

线程共享，是一块逻辑区域，不同的虚拟机可以有不同的实现，存放被虚拟机加载的类信息、字段信息、方法信息、常量、静态变量、及时编译器生成的代码缓存等数据

在Hotspot虚拟机中，实现为永久代，在JAVA后被元空间替代

### 永久代和元空间内存使用上的差异

- 永久代使用JVM虚拟内存，大小固定；而元空间使用本地内存，大小受操作系统内存限制
- 永久代存储类信息、静态变量、常量等等；而元空间仅存储类信息（静态变量、常量存放在推中）

### 运行时常量池

线程共享，存放常量表，常量表中保存编译产生的字面量和符号引用

### 字符串常量池

专为字符串设计的常量池，用于保存字符串常量的引用

### 直接内存

不属于JVM运行时数据区域，是本地内存的一块区域

### 对象的创建过程

1. 检查类信息是否已经被加载，如果类没有加载，就先执行类的加载过程
2. 为对象分配内存空间
3. 初始化内存地址
4. 设置对象头，包括：对象属于哪个类，对象的哈希值，对象的GC分代年龄信息等等
5. init()方法初始化对象

### 对象的内存布局

- 对象头：包括两部分信息
  - 自身运行时数据：对象的hash值，对象的GC生代年龄信息
  - 类型指针：指向类元数据的指针
- 实例信息：对象自身的数据
- 对齐填充：由于JVM中要求对象的大小是8字节的整数，因此对象本身空间不满足，就使用对其填充部分进行占位

### 对象的访问定位

java程序通过栈上的reference信息来访问对象进行操作。而具体的访问方式由虚拟机实现决定，主流有两种：

- 句柄：：内存额外维护一个句柄池，reference保存的是句柄引用，句柄中保存了对象的实例地址以及对象所属类信息的地址
- 直接引用：reference保存的就是对象的直接地址

使用句柄的好处在于，在移动对象时，只需要修改句柄引用就行了；而直接引用的好处在于，减少一次指针引用，速度较快

### 推的空间划分

- 新生代（包括eden和Survivor）
- 老生代
- 永生代（在java8后替换为元空间，元空间使用直接内存）

### 对象内存分配策略

- 对象创建优先在新生代分配，当新生代空间不足时，会进行一次MInor GC（新生代收集），基于空间分配担保机制（确保老生代可以接收新生代的所有对象，或者MinorGC平均对象）腾出空间。
- 大对象直接在老生代分配，大对象例如：字符串、数组，这是为了避免大对象在分配担保机制下发生的复制而降低效率
- 长期存活的对象进行老生代：JVM给所有对象设置了一个年龄计数器，大多数对象创建在eden，在经历一次Minor GC会进入survivor并且age变为1，之后没经历一次Minor GC后幸存都会使年龄加1，当到达设置的阈值时就会进行老年代
- 动态对象年龄判定：当survivor区中相同年龄的对象数量大于总和的一半，则大于等于该年龄的对象进行老生代（不用要求到达年龄阈值）
- 空间分配担保：在Minor前，虚拟机会检查新生代所有对象空间是否大于老生代剩余空间，如果是则认为不安全；此时检查是否设置允许担保失败，如果允许担保失败，那么再检查老生代剩余空间是否大于历次GC新生代转移到老生代的平均数量，如果不满足或者不允许担保失败则触发full GC

### 垃圾回收过程

1. 刚开始eden、s1区和s2区都空，程序开始对象不断创建在eden区
2. 当eden区占满，触发Minor GC，将eden区中存活对象复制到s1区，然后清除eden区
3. 当eden又占满时，触发Minor GC，将eden区和s1中的存活对象复制到s2区，然后清除eden区和s1区
4. 当eden又又占满时，触发Minor GC，eden区和s2中的存活对象复制到s1区，然后清除eden区和s2区
5. s1和s2区交替使用，总是一个区存放对象，另一个区为空（标记-复制算法）
6. 每次GC后，对象的年龄加1，到阈值后（默认15）进入老生代
7. 当老生代占满时，触发Major GC（即full GC）
8. 当GC后仍占满，则OOM

### 什么是 TLAB （Thread Local Allocation Buffer）

在eden区进行划分，为每个线程分配一个私有缓存区域；在多线程并发下，这种方式无需加锁就可以保证对象创建的线程安全，也称快速分配策略

不过这个区域很小，线程首先尝试在这个区域创建，失败再通过锁的方法创建

### 进行GC的区域

- 部分收集：

  - 新生代收集

  - 老生代收集

  - 混合收集

- 全堆收集

### 死亡对象判断方法

- 引用计数法：为对象添加一个引用计数器，当被引用时就+1，当引用失效时就-1，当计数器为0时，则判断对象不可用。但是这个方法无法解决循环引用的问题
- 可达性分析法：JVM选出一系列对象作为GC root，当一个对象无法通过引用达到GC root时，则认为该对象不可用，可以作为GC root的对象有：
  - 虚拟机栈中引用的对象
  - 本地方法栈中引用的对象
  - 方法区中类静态变量引用的对象
  - 方法区中常量引用的对象
  - 所有被同步锁持有的对象

在不可达分析中，对象要被标记两次才会被真的清除

### 引用类型以及引用队列

- 强引用：实际使用中最为常见，当对象具有强引用，收集器不会将其回收，内存不足时报错
- 软引用：SoftReference，当内存足够时，不会被回收，当内存不足时会被回收，可以配合引用队列来使用
- 弱引用：WeakReference，当内存足够时，收集器也会将其回收，可以配合引用队列使用
- 虚引用：有跟没有一样，必须配合引用队列使用
- 引用队列：当对象将要被JVM回收时，就会加入引用队列，那么程序可以通过引用队列查看被回收的对象情况

### 如何判断一个变量是废弃变量

没有任何引用，并且需要清理内存时

### 如何判断一个类是无用的类

- 类的所有实例都已被回收，即类没有实例
- 类加载器ClassLoader对象已被回收
- 类对象Class在所有地方没有被引用

满足以上三个条件，则类可以被回收

### 什么情况触发full GC

- 调用System.gc
- 老生代空间不足
- 空间分配担保失败
- jdk1.7之前永生代空间不足
- concurrent mode failure：并发场景下，在GC时创建新对象无法放入老生代（浮动垃圾过多导致的暂时性空间不足）

## 垃圾收集算法

### 标记-清除

分为两个阶段：

- 先将所有不需要回收的对象进行标记
- 统一将需要回收的对象进行清除

存在的问题：

- 标记和清除的过程效率都不高
- 会产生大量的内存碎片

### 复制算法

将内存分为大小相同的两块，每次使用其中的一份。将垃圾回收时，先将回收的对象进行标记，然后把不需要回收的对象复制到另一块空闲的内存，然后当前的这一份内存清空。可以解决内存碎片的问题

存在的问题：

- 可用内存变为一半
- 如果存活的对象数量较大，复制的效率会很低

### 标记-整理

分为两个阶段：

- 标记
- 整理：让所有存活的对象向一端移动，然后清除边界外的内存

可以解决内存碎片问题，但效率更低，所以一般用于回收频率较低的老生代

### 分代收集算法

根据不同的分代选择合适的算法：

- 新生代：每次收集都有大量的对象被回收，因此采用“标记-复制”算法，复制成本较小
- 老生代：其中的对象存活时间较长，因此采用“标记-清除”或者“标记复制”

## 垃圾收集器

### Serial收集器

工作在新生代，串行收集器，是单线程的，并且当进行垃圾回收时，需要Stop The World！，停止其他所有的工作线程

Client 模式下的默认新生代收集器

### ParNew收集器

工作在新生代，Serial收集器的多线程版

 Server 模式下的虚拟机首选新生代收集器

### Parallel Scavenge收集器

工作在新生代，类似Serial的多线程收集，不过它以提高吞吐量为目标，即高效地利用CPU，是jdk1.8默认的垃圾收集器

可以设置许多参数（例如停顿时间，吞吐量大小）来优化性能，也可以配合自适应调节策略

### Serial Old收集器

Serial收集器的老年代版本，采用“标记-整理”算法

### Parallel Scavenge Old收集器

Parallel Scavenge收集器的老年代版本，采用“标记-整理”算法

### CMS收集器

工作在老生代，以缩减停顿时间为目标的收集器，注重用户体验，并且是并发收集器。将GC过程划分成不同的阶段，一些阶段采用并发的方式，运作过程分为四个阶段：

- 初始标记：这个阶段会暂停用户线程，记录与GC root直接相连的对象，这个阶段会产生停顿
- 并发标记：并发启动用户线程和GC线程，这个阶段收集器追溯所有对象并标记，并且还会记录这段时间对象所发生的变动，这个阶段是并发进行的
- 重新标记：这个阶段根据并发标记阶段所记录的变动而修正标记，这个阶段会产生停顿
- 并发清除：将未标记的对象进行清除，这个阶段是并发进行的

优点：并发收集、停顿短

缺点：

- 对CPU资源敏感（占用CPU）
- 无法处理浮动垃圾
- 使用“标记-清除”会产生大量内存碎片

### G1收集器

一款面向服务器的垃圾收集器，在CPU核心数数量多和内存空间大的条件下，可以充分发挥硬件优势，既能保证较小的停顿时间，又可以保持较高的吞吐量。G1收集器将堆划分为许多小区域，各个区域可以独立进行垃圾回收。这种方式十分灵活，避免扫描整个堆，并且维护一个优先级队列，会优先去收集价值高的区域。

特点：

- 并发与并行：G1收集器充分利用多核CPU，使用多个CPU来减小停顿时间
- 分代收集：G1收集器可以独自直接管理整个堆，不过依然保留了分代的概念
- 空间整合：整体采用“标记-整理”，局部采用“标记-复制”，避免内存碎片
- 停顿可预测：可以预测停顿的时间，可以设置一段时间内停顿的最长时间

G1收集的运作步骤：

- 初始标记
- 并发标记
- 最终标记：修正并发期间因为用户程序运行而导致变动的标记，此阶段会停顿
- 筛选回收：首先对各个区域的回收价值和成本进行排序，根据用户期望的停顿时间来制定回收计划

G1在后台会维护一个优先级列表，每次根据允许的收集时间，优先收集优先级高的区域，从而保证有限的时间内尽可能高的回收效率

### ZGC收集器

不太了解

### 类文件结构

- 魔数：确定文件可以被虚拟机接受
- 版本号：java版本
- 常量池：常量池中包括字面量（final常量、字符串）和符号引用（类名、方法名、属性名）
- 访问标识：标识类的相关信息，比如访问修饰符、是否接口等等
- 继承关系：当前类、父类、接口集合
- 字段表集合：描述类中声明的变量
- 方法表集合：描述类中声明的方法
- 属性表集合：？

## 类加载

### 类的生命周期

- 加载：查找并加载类的二进制文件
- 验证：确保类的正确性
- 准备：为类的静态变量分配内存，初始化为默认值
- 解析：将类中的符号引用转换为直接引用
- 初始化：为类的静态变量赋予正确的初始值，
- 使用
- 卸载

其中，验证、准备、解析可以合并为连接

### 类加载过程

- 加载
- 连接
  - 验证
  - 准备
  - 解析
- 初始化

### 加载

这个阶段主要由类加载器来完成，分为三部步骤：

- 通过全类名加载类的二进制字节流
- 将存储在类文件中的静态结构转换为方法区运行时的数据结构
- 在内存中生成该类的Class对象，作为方法区这些数据的入口

### 验证

分为四个阶段：

- 文件格式验证：检验字节流是否符合规范，例如：版本号、常量类型等
- 元数据验证：检验字节码提供的信息是否符合规范，例如：继承关系等
- 字节码验证：检验程序语义是否正确，合乎逻辑，例如：参数类型、类型转换等
- 符号引用验证：检验类的正确性，例如：字段、方法是否正确

其中只有文件格式验证是基于字节流的，其余阶段都是基于内存中方法区数据的

### 准备

为类变量分配内存空间并赋初始值，其中：

- 类变量指静态变量，理论上存放在方法区；而实例变量是随着对象创建一起放在堆中
- 初始值对于一般变量指数据的默认值（初始化阶段才赋指定的值），而final修饰的变量初始值就会直接被赋上指定值

### 解析

将符号引用转换为直接引用

### 初始化

执行`<clinit>`方法进行类的初始化，这个方法是线程安全的

虚拟机规定了以下5种情况必须对类进行初始化

- 当使用new创建实例，使用静态变量，使用静态方法时会初始化
- 对类进行反射调用时
- 使用了子类会先将父类初始化
- 用户定义的主类（包含main方法）会在虚拟机启动时被初始化
- `MethodHandle` 和 `VarHandle` 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 `findStaticVarHandle` 来初始化要调用的类
- 当接口写了默认方法，则当使用实现类之前会将接口初始化

### 类卸载

即类被GC，满足一下三个条件：

- 堆中没有任何该类的实例
- 类的引用没有在任何地方使用
- 类加载器已被GC

在JVM的生命周期中，JVM自带的类加载器不会被GC，而自定义的类加载器可以被GC

## 类加载器

### 类加载器是什么

类加载器用于类的加载过程，作用是将对应类的字节码文件加载到内存中（除了数组类由JVM直接生成）

### 有哪些类加载器

从上到下为：

- `BootstrapClassLoader`：启动类加载器，负责加载核心类库
- `ExtensionClassLoader`：拓展类加载器
- `AppClassLoader`：面向用户的下载器，加载`classpath`下的类
- `User Classloader`：自定义类加载器

除了`BootstrapClassLoader`是JVM的一部分，其余类加载器都是JVM外部实现的，并且继承自抽象类`ClassLoader`

每个 `ClassLoader` 可以通过`getParent()`获取其父 `ClassLoader`，如果获取到 `ClassLoader` 为`null`的话，那么该类是通过 `BootstrapClassLoader` 加载的。

### Class.forName()和ClassLoader.loadClass()区别

- `Class.forName()`：将类加载到JVM中，还会对类进行解释，执行类中的staic块（可以通过参数控制）
- `ClassLoader.loadClass()`：仅仅将类加载到JVM中，只有当`newInstance`时才会执行static块

### 自定义类加载器

自定义类加载器要继承`ClassLoader`,其中有两个关键方法：

- `loadClass`：根据二进制类名加载类，实现了双亲委模型
- `findClass`：根据二进制类目发现类，默认空方法

如果不想打破双亲委派机制，则只需要重写`findClass`，如果不想使用双亲委派模型，则要重写`loadClass`

### 类加载机制有哪些？

- 全盘委托：当一个类加载负责一个类的加载时，该类所依赖和引用的其他类都由该类加载器加载
- 父亲委托：先让父加载器来进行加载，不行再自己加载
- 缓存机制：所有加载的类对象都会被缓存
- 双亲委派机制：加载类时会委托给父加载器进行，不断委托直到顶层类加载器，若都无法加载才会自己加载

### 双亲委派模型执行流程

- 类加载器先判断这个类是否已被加载，已加载就直接返回
- 没有加载过的类，会先调用父类加载器的`loadClass`方法进行加载，这样一直传递到启动类加载器
- 父类加载器没有加载失败，则调用自己的`findClass`进行类加载

### 双亲委派模型的好处

保证类的唯一性，因为会保持向上委托，只有当确认所有父加载器都没有加载过该类，才会调用自己的类加载进行加载

## JVM参数

### 堆内存相关

- `-Xms`：指定堆的最小空间
- `-Xmx`：指定推的最大空间
- `-XX:NewSize`：指定新生代最小空间
- `-XX:NewMAXSize`：指定新生代最大空间
- `-Xmn`：指定新生代空间（最大和最小一致）
- `-XX:NewRatio`：指定新生代和老生代比例
- `-XX:PremSize`：指定方法区（永久代）的初始空间
- `-XX:PremMaxSize`：指定方法区（永久代）的最大空间
- `-XX:MetaspaceSize`：指定元空间触发full GC的阈值，初始大小由平台决定
- `-XX:MetaspaceMaxSize`：指定元空间的最大空间

### 垃圾收集器选择

```sh
-XX:+UseSerialGC
-XX:+UseParallelGC
-XX:+UseParNewGC
-XX:+UseG1GC
```

### GC日志记录

```sh
# 必选
# 打印基本 GC 信息
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
# 打印对象分布
-XX:+PrintTenuringDistribution
# 打印堆数据
-XX:+PrintHeapAtGC
# 打印Reference处理信息
# 强引用/弱引用/软引用/虚引用/finalize 相关的方法
-XX:+PrintReferenceGC
# 打印STW时间
-XX:+PrintGCApplicationStoppedTime

# 可选
# 打印safepoint信息，进入STW阶段之前，需要要找到一个合适的 safepoint
-XX:+PrintSafepointStatistics
-XX:PrintSafepointStatisticsCount=1

# GC日志输出的文件路径
-Xloggc:/path/to/gc-%t.log
# 开启日志文件分割
-XX:+UseGCLogFileRotation
# 最多分割几个文件，超过之后从头文件开始写
-XX:NumberOfGCLogFiles=14
# 每个文件上限大小，超过就触发分割
-XX:GCLogFileSize=50M
```

### 处理OOM

JVM提供一些参数用于将内存转储到文件中，以便排查问题

- `-XX:+HeapDumpOnOutOfMemoryError`：JVM在OOM时将heap存入文件
- `-XX:HeapDumpPath=./java_pid<pid>.hprof`：表示要写入文件的路径; 可以给出任何文件名; 但是，如果 JVM 在名称中找到一个 `<pid>` 标记，则当前进程的进程 id 将附加到文件名中，并使用`.hprof`格式
- `-XX:OnOutOfMemoryError="< cmd args >;< cmd args >"`：用于在OOM时发出紧急命令，`cmd args` 空间中使用适当的命令
- `-XX:+UseGCOverheadLimit`：用于限制OOM之前花费在GC中的时间

### 其他

- `-server` : 启用“ Server Hotspot VM”; 此参数默认用于 64 位 JVM

- `-XX:+UseStringDeduplication` : *Java 8u20* 引入了这个 JVM 参数，通过创建太多相同 String 的实例来减少不必要的内存使用; 这通过将重复 String 值减少为单个全局 `char []` 数组来优化堆内存。

- `-XX:+UseLWPSynchronization`: 设置基于 LWP (轻量级进程)的同步策略，而不是基于线程的同步。

- `-XX:LargePageSizeInBytes `: 设置用于 Java 堆的较大页面大小; 它采用 GB/MB/KB 的参数; 页面大小越大，我们可以更好地利用虚拟内存硬件资源; 然而，这可能会导致 PermGen 的空间大小更大，这反过来又会迫使 Java 堆空间的大小减小。

- `-XX:MaxHeapFreeRatio` : 设置 GC 后, 堆空闲的最大百分比，以避免收缩。

- `-XX:SurvivorRatio` : eden/survivor 空间的比例, 例如`-XX:SurvivorRatio=6` 设置每个 survivor 和 eden 之间的比例为 1:6。

- `-XX:+UseLargePages` : 如果系统支持，则使用大页面内存; 请注意，如果使用这个 JVM 参数，OpenJDK 7 可能会崩溃。

- `-XX:+UseStringCache` : 启用 String 池中可用的常用分配字符串的缓存。

- `-XX:+UseCompressedStrings` : 对 String 对象使用 `byte []` 类型，该类型可以用纯 ASCII 格式表示。

- `-XX:+OptimizeStringConcat` : 它尽可能优化字符串串联操作。

### JDK命令行工具

- `jps`：查看所有java进程的状态
- `jstat`:查看虚拟机的各种运行状态
- `jinfo`：显示虚拟机配置信息
- `jmap`：生成堆转储快照文件
- `jhat`：用于分析heapdump文件，它会建立一个服务器，让用户通过浏览器查看
- `jstack`：生成虚拟机当前时刻的线程快照（正在执行的方法堆栈情况）

### JConsole

基于JMX的可视化监控工具，可以方便的监视java进程的内存使用情况，具有丰富功能：

- 内存监控：可以直观地看到内存区域的使用情况，可以强行执行GC
- 线程监控：类似`jstack`，可以检测死锁

### Visial Vm

多合一故障处理工具，支持插件拓展，具备非常完备的功能

## JAVA新特性

### java8新特性

- `Interface`：接口中方法可以被`static`或`defaual`修饰，被`static`修饰时无法重写被直接调用，被`default`修饰时无法重写（解决了增加接口方法时需要修改所有实现类的问题）
- `functional interface`：函数式接口，有且只有一个抽象方法但可以有多个非抽象方法的接口
- `lambda`表达式：与函数式接口配合，简化代码。可以使用：：进行方法引用
- `Stream`流：通过链式编程方便的遍历数据并进行处理
- `Optional`：用于判断非null，解决嵌套对象的判空问题，NPE问题
- `Date time-api`

### java9+新特性

举些例子：

- java10——并行全垃圾回收器
- java11——ZGC：可伸缩低延迟垃圾回收器
- java14——switch表达式（正式版）
- java14——record类型：类似Lombok的@Data注解