# MySQL

## SQL

### MySQL执行流程

1. 连接器：基于TCP与MySQL进行连接
2. 查询缓存：查询SQL语句是否具有缓存
3. 解析SQL：词法分析与语法分析，判断SQL语句是否有误
4. 执行SQL：预处理、优化、执行

### MySQL一行记录是如何储存的

compact行格式：分为记录的额外信息和记录的真实信息

记录的额外信息包括：

- 变长字段长度列表：记录变长字段的长度
- null值列表：记录哪些位置是null
- 记录头信息：标记是否被删除，指向下一条记录，记录的类型等等

### 行溢出后，MySQL如何处理

将多出的数据记录到溢出页，并在真实数据处用20字节记录指向溢出页的地址

### InnoDB和MylSAM的区别

- 支持事务——不支持事务
- count()会扫描全文统计——记录count
- 支持外键——不支持外键
- 支持行级锁——不支持行级锁

### 分库分表怎么做

当数据量非常大时需要进行分库分表，首先考虑垂直切分，其次考虑水平切分

- 垂直切分：将表结构进行细分，形成多个不同结构的表。例如电商数据库中将用户信息和商品信息切分
- 水平切分：将表数据分表存储，例如订单信息表按时间划分，每三个月形成一张表，或者按主键id通过hash映射到索引位置来进行表的划分

分表后就无法使用自增主键id，考虑使用分布式算法：例如雪花算法生成全局唯一id

### 读写分离方案

主库用来读，从库用来写，从而提高性能：

- 读和写操作在各自的数据库中进行，避免了锁资源争抢
- 数据库冗余，增加可用性
- 从数据库可以使用MyISAM，节省开销提升查询性能

实现方案：采用代理服务器，根据请求类型、数据库负载情况进行转发

## 索引

### 什么是索引

相当于数据的目录，是一种排序的数据结构，常见的底层结构是B+树，可以帮助快速进行查询；但索引有缺点，就是维护索引需要额外的空间，并且创建索引和维护索引都需要一定的时间消耗。因此要根据具体的业务情况来决定是否使用索引，例如在一些频繁使用，用于缩小查询范围或者用于排序的字段上可以使用索引；但是如果有些字段查询次数较少或者重复值较多就不适合建立索引。

### 索引的分类

- 数据结构角度：B+索引，Hash索引，全文（full-text）索引
- 物理存储角度：主键索引，二级索引
- 字段特性角度：主键索引，唯一索引，普通索引，前缀索引
- 字段个数角度：单列索引，联合索引

### 索引优化的方式

1. 前缀索引优化：使用字符字段前几个字符作为索引，可以节省空间，但无法排序、覆盖索引
2. 覆盖索引优化：使用联合索引来避免回表
3. 使用自增主键：在插入新数据的时候减少调整操作（页分裂）
4. 使用NOT NULL：null值会使索引变得更加复杂，并且占用空间
5. 反正索引失效

### innodb的数据存储结构

innodb的数据按照数据页进行读写，一个数据页中包含许都的记录，从而减少IO次数。通过B+树为数据页创建索引，每个节点都是一个数据页。数据也内部有页目录，用于存储各个槽，并且主键有序，从而可以通过二分查找快速找到数据

### 为什么MySQL用B+树作为索引

B+树是一种多叉树结构，较比于二叉树，树的高度会小很多，大大减少了对磁盘的访问次数。

而相比于B树，B+树只在叶子节点存储数据，非叶子节点存储索引，那么在相同的数据量下，B+的非叶子节点可以存储更多数据，从而进一步减少树的高度；并且B+树的非叶子节点不存储数据，其实都是冗余节点，这种结构使得B+树在插入和删除时比B树方便许多；B+树中所有的数据都出现在叶子节点，并且使用双向链表连接，更有利于范围查询

### 索引什么时候会失效

1. 使用左或者左右模糊查询：B+树为有序结构，单前缀不明确是，无法进行比较
2. 使用函数表达式：使用了函数后索引列的值发生变化，自然无法使用索引
3. 对字段进行计算：原理于函数一样
4. 隐式类型转换：当查询字段为字符串，而查询条件输入为数字，MySQL自动将字符串字段转为数字，相当于使用了函数
5. 联合查询非最左匹配：使用联合查询时，按照最左优先的原则对联合索引进行组合，如果最左字段不匹配，则索引失效
6. 使用or：使用or表示多个条件满足一个就行，那么只有一个条件是索引是没有意义的

### count（？）以及如何优化

count（1），count（*），count（主键）：本质上都一样，如果有二级索引，那么扫描key-len最小的二级索引；没有就扫描主键索引

count（字段名）：性能很差，会进行全面扫描

优化：近似值（explain），额外表记录个数

### MySQL问题排查有哪些手段

- show processlist：查看所有连接情况
- EXPLAIN：查看SQL语句执行计划
- 开启慢查询日志，查看日志进行排查

## 事务

### 事务有哪些特性

- 原子性：指一个事务中的所有操作要么全部执行，要么全部不执行。若在事务中某个操作执行失败，则事务回滚到初始状态
- 一致性：指事务前后，数据满足完整性约束，数据库保持一致性状态
- 隔离性：数据库支持多个事务对数据库进行操作，各个事务有自己的隔离空间， 互相不干扰
- 持久性：事务对数据的修改是永久的

### InnoDB如何保证事务四个特性

- 原子性：undo log
- 一致性：代码层面
- 隔离性：MVCC版本控制
- 持久化：redo log刷盘

### 并发事务会发生什么问题

- 脏读：读到未提交的修改数据
- 不可重复读：多次读取数据得到的结果不一致
- 幻读：多次读到的数据记录数不一致，也就是新增了原来不存在的数据

### 四种隔离级别

- 读未提交：指一个事务未提交的修改可以被其他事务看到，会出现脏读、不可重复读、幻读

- 读已提交：指一个事务只有提交后它的修改才会被其他事务看到，会出现不可重复读，幻读

- 可重复读：指事务结束前看到的数据开启事务时的数据一样，会出现幻读（MySQL可以很大程度上避免）

- 串行化：对记录加上读写，直到事务结束才释放

### MVCC是怎样实现的

MVCC是通过read view和undo log来实现的

Read View是一个快照，其中主要保存了当前事务的序号，目前正在活跃的事务序号列表，还有最小活跃事务序号和下一个事务序号。而行记录中有两个隐藏字段，一个用于记录最近对记录进行改动的事务序号，还有一个用来指向旧版本记录形成历史版本记录的链表

对于读已提交隔离级别：事务开始时会生成read view，并且事务在每次读取数据时都会重新创建Read View

对于可重复读隔离级别：事务开始时生成read view，直到事务结束都使用这个版本

当读取数据时，数据中有隐藏信息包括：最近修改该记录的事务id，指向上一个版本记录的指针（形成历史版本链），事务会判断该记录的版本是否符合要求，如果不符合就追溯历史版本链找到合适的记录进行读取

### 可重复读如何避免幻读问题

对于快照读：通过并行版本控制来避免幻读，每次读取每次追踪版本记录，新插入的记录自然无法查到

对于当前读：进行当前读时会加上记录锁和间隙锁，其他事务操作时会堵塞，直到加锁的事务结束释放

出现幻读的情况：先进行快照都，此时读到的是历史数据，再进行当前读，此时读到的是最新数据，之后再进行快照都，记录变成了最新版本

## 锁

### MySQL有哪些锁

按锁的范围可以分为：

- 全局锁：对整个数据库进行加锁
- 表级锁：
  - 表锁：对一张表加锁
  - 元数据锁：自动添加的锁。当对表进行crud时，自动加上MDL读锁，当对表结构进行更改时，会自动加上MDL写锁
  - 意向锁：在对记录施加共享锁和独占锁时，会对表施加意向共享锁和意向独占锁，从而快速的判断一张表是否加了锁
  - AUTO-INC锁：表设置了主键自增，那么在添加记录时，会施加锁，根据设置的等级模式的规则释放锁：
    - 等级0：语句执行完才释放
    - 等级2：自增主键赋值后就释放
    - 等级1：当普通插入时，自增完释放；当批量插入时，语句执行完释放
- 行级锁
  - 记录锁：对记录加锁
  - 间隙锁：对某个范围加锁
  - 临键锁：记录锁+间隙锁，左开右闭
  - 插入意向锁：当事务要添加的记录被其他事务的间隙锁堵塞，就会生成一个插入意向锁，等待其他事务结束

### 行级锁怎么加？

- 对于唯一索引
  - 等值查询：
    - 对于存在的记录：退化为记录锁
    - 对于不存在的记录：退化为间隙锁
  - 范围查询：
    - 记住左开右闭，视情况退化成记录锁或者间隙锁

- 对于非唯一索引

  - 等值查询：
    - 对于存在的记录，在满足条件记录处添加next-key锁，在第一个不满足条件记录处添加间隙锁，并且限制主键id小于该处的记录新增，同时主键索引处添加记录锁
    - 对于不存在的记录，在第一个不满足条件记录处添加间隙锁，主键索引不用加锁

  - 范围查询：
    - 与唯一索引的不同在于，不会退化为记录所或者间隙锁（为了反正插入相同数据的记录，但也不一定防的住，要根据主键索引判断）
    - 同时主键会加记录锁

- 对于没有索引
  - 全表扫描，有记录就加锁
  - 要避免不用索引对全表使用会加锁的查询，可以开启mysql的安全更新模式来避免

### MySQL发生死锁

原因：由于间隙锁是共享的，当两个事务获取到了相同范围的间隙锁，并且两个事务往范围内插入记录，那么两个事务会等待间隙锁释放而全部阻塞，形成死锁

避免：设置事务等待锁的超时时间，超时就回滚事务；开启主动检测死锁，检测到了就回滚

## 日志

### undo日志的作用

保证原子性，实现事务回滚

结合read view实现MVCC（多版本并发控制）

### redo日志的作用

存在的问题：由于数据修改会首先在内存中形成脏页，后续调用其他线程进行数据同步，那么如果中间MySQL崩溃，那么已经修改的数据就丢失了

作用：保证持久性，redo日志记录了事务对于记录的修改操作，事务提交时持久化到磁盘，从而记录了更新后的数据；同时写入redo日志相较于直接写入数据，由随机写变成了顺序写，提升了磁盘写入性能

### redo和undo的区别

redo记录事务完成后的操作，用于事务提交后崩溃后数据修改仍被保存

undo记录事务开始后的操作，用于事务进行中崩溃后回滚到原始版本

### redo什么时候刷盘

通过参数设置控制：

- 0：在事务提交时不会持久化
- 1：在事务提交时持久化
- 2：在事务提交时写入操作系统的文件缓存

同时，每隔1秒线程会将redo持久化

数据安全性：1>2>0

性能：0>2>1

### redo满了怎么办

redo日志采用循环写的方式，从头开始写，写道末尾又回到起点。写的时候会有两个指针，write pos表示要写如redo记录的位置，check point表示当前要擦除的redo记录位置，当write pos追上check point，表示redo日志写满了，此时MySQL会阻塞，等待redo日志写入磁盘后擦除腾出空间，然后回复正常工作

### redo log和binlog有什么区别

使用对象不同：

- binlog属于server层，所有存储引擎都可以用
- redo log是InnoDB引擎实现的日志

文件格式不同：

- binlog有三种格式：
  - statement格式；这种属于逻辑日志，主要记录了对表操作的逻辑，但是无法保存动态函数所产生的值
  - row格式：这种记录了行被修改后的信息，不会出现动态函数相关问题。但是，它记录了所有被修改的行的信息，那么占用的空间会更大
  - mixed模式：前两种模式的混合模式，根据不同的情况来使用statement或者row
- redo log数据物理日志，记录了数据页中的哪一条记录的修改

写入方式不同：

- binlog是追加写，当文件写满后会创建新的文件继续写
- redo log是循环写，一边写一边擦除

用途不同：

- binlog适用于数据库备份，主从复制
- redo log适用于故障恢复

### 主从复制如何实现

MySQL使用binlog日志实现主从复制，一般采用异步模型：

1. 写入binlog：主库提交事务前保存binlog日志，提交事务后，更新主库数据（涉及binlog线程）

1. 复制binlog：调线程把binlog日志复制到从库，从库进行保存（涉及IO线程）
1. 回放binlog：从库通过回放binlog将数据进行更新（涉及SQL线程）

一般主库用于写，从库用于读，从而读写不会互相堵塞

### 主从复制还有哪些模型

- 同步模型：当客户端发送请求时，主库等待从库完成更新后才返回客户端结果，性能会很差
- 异步模型：当主库提交事务后，先返回客户端结果，异步执行数据同步操作，默认模型
- 半同步：当主库提交事务后，等待部分从库完成更新在保存结果，之后异步操作同步所有数据库，这样操作可以保证最新的数据不会丢失

### binlog什么时候刷盘

binlog会先写到内存中的缓冲区，然后再写入操作系统的文件缓存，最后持久化到磁盘。可以通过参数控制策略：

- 0：每次事务提交后写入文件缓存，然后由操作系统决定何时写入磁盘，默认
- 1：每次事务提交后写入文件缓存，并且立即写入磁盘
- N(大于1)：每次事务提交后写入文件缓存，累计N个事务提交后一起写入磁盘

一般设置为N=100~1000

### 两阶段提交执行过程

在事务提交时，MySQL会开启一个内部XA事务，这个事务分为两个阶段：

1. prepare阶段：将XID（内部事务id）写入redo log中，并将redo log持久化，同时对应的事务状态设置为prepare
1. commit阶段：将XID写入binlog中，并将binlog持久化，同时对应的事务状态设置为commit，状态信息写入文件缓存，无需持久化

通过检查binlog中是否有XID一致来判断事务是否执行成功，因此事务是否成功取决于binlog是否写入；MySQL崩溃后，binlog成功写入了，那么就使用redo恢复事务，如果binlog没有写入，那么就回滚事务。

### 两阶段提交的问题

- IO次数高：每次提交事务时都要进行两次刷盘，影响性能
- 锁竞争激烈：在多事务场景下，需要保证日志顺序的正确，那么就要争抢锁，导致锁竞争激烈

### MySQL 磁盘 I/O 很高，有什么优化的方法？

通过控制参数来减少redo log和bin log的刷盘次数

- 将 sync_binlog设置为大于1的N，那么累计N事务提交后才会将bin log写入磁盘
- 将 innodb_flush_log_at_trx_commit设置为2，那么redo log会写入文件缓存，然后交给操作系统来写入磁盘

## 内存

### Buffer Pool的作用

MySQL中的缓存池，可以减少IO操作次数，提升性能

对于查询操作：击中就返回；没有就查磁盘，并且将页加载到buffer pool

对于修改操作：如果BufferPool中有记录，则修改BufferPool中的数据，并设置脏页，另外调线程进行同步

Buffer Pool按页存储，包括：数据页，索引页，undo页，插入缓存页，自适应哈希缓存索引，锁信息

### 如何管理空白页

使用链表结构，将空白页的控制块（包含空白页地址）作为节点，头节点记录节点个数，起终节点地址，形成Free链表，脏页管理类似（Flush List）

### 如何避免预读失效和缓存污染？

预读失效：将LRU算法划分为两个区域，分别时young区域和old区域，其中young代表热点数据，预读的数据会先进入old区域，等真正被访问时才会进入young区域，从而避免预读数据将热点数据顶替

缓存污染：提高进入young区域的门槛来避免某次大量查询的数据顶替掉热点数据，具体是只有当数据被两次访问，并且两次访问的时间间隔大于某个值（1000ms）才会从old区域换到young区域

### 脏页什么时候被刷入磁盘

- redo日志空间满了
- 缓冲池空间满了
- MySQL认为空闲时
- MySQl关闭时会将所有的脏页写入磁盘